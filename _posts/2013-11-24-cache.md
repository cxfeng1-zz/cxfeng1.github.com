---
layout: post
title: "缓存"
description: ""
category: Programming
tags: [Caching]
---
{% include JB/setup %}

缓存是一项加速数据读取的技术。有了缓存之后，你就不用再直接回源去取数据了，这个“源”可能是数据库，也可能是其他的远程系统。
基本的缓存原则如下图：

![pic](/images/caching-1.png)

所谓缓存，其实就是比“源”更“近”的一个存储区域，从缓存中读取数据一般比从源数据读取要更快。
缓存一般存储中内存或者磁盘中。内存比磁盘更快，但是内存中的缓存会在系统重启后消失。

典型的软件系统中，数据缓存会发生在很多不同的层级。目前的web应用一般会在三个层级上使用缓存：

![pic](/images/caching-2.png)

大多数web应用会使用数据库。数据库可以把数据缓存在内存中这样就不用每次从磁盘中读取了。同样的，
web服务器可以缓存一些如图片、CSS文件，JS文件之类的静态数据在内存中，也可以缓存从数据库中读取的数据，这样
它就不用每次都去数据库读数据了。最后浏览器也可以缓存静态的文件和数据，HTML5浏览器有
[local storage](http://tutorials.jenkov.com/html5/local-storage.html),[Appcache](http://www.html5rocks.com/en/tutorials/appcache/beginner/)
以及[web SQL 数据库](http://html5doctor.com/introducing-web-sql-databases/)

在实现一个缓存系统的时候，你需要考虑三件事情：

* 怎么填充缓存
* 怎么保持缓存和源数据的同步
* 怎么管理缓存的大小

##填充缓存

第一个挑战便是怎么用源数据来填充缓存。一般有两种方式:

* 预填充
* 懒填充

预填充意思就是在拥有缓存的系统启动的时候就把需要的值存储到缓存中去。
这个方式需要你能够预先知道该缓存哪些内容。

懒填充意思是当你需要某些数据的时候，首先去检查缓存中有没有，没有就从源系统中获取
并填充到缓存中。

预填充和懒填充的好处和坏处可以用下表概括：

<table>
<tr>
<td></td>
<td>好处</td>
<td>坏处</td>
</tr>
<tr>
<td>预填充</td>
<td>预填充没有第一次读取数据的延时</td>
<td>初始化缓存花费时间长，同时可能会缓存永远都用不到的数据</td>
</tr>
<tr>
<td>懒填充</td>
<td>懒填充只缓存真正需要的数据，也没有初始构建时的延时</td>
<td>在第一次读取数据时还是要从源服务器读，前后用户体验会不一致
</tr>
</table>

当然，可以将预填充和懒填充结合起来，预先将经常被读取的数据放入缓存，
然后其余的数据通过懒填充放入缓存。

##保持缓存和源数据同步

这同样是一个很大的挑战，基于系统结构的不同，同步的方法也有很多。

###直写缓存

直写缓存是一种既允许读又允许写的缓存，如果有数据写入缓存，那这些数据
同样会写到源系统中，所以称它为"直写"。

直写缓存主要应用于源系统只能被缓存所更新的情况。如果所有数据写入都是
拥有缓存的计算机造成的，那通过写入源系统来保持同步就比较简单了。

###基于时间过期

如果源系统的数据更新跟拥有缓存的计算机无关，那就不适合用直写了。

有一种同步方法是让数据在缓存中存在一定的时间，过期了数据就会从缓存中删除。
当又需要这个数据的时候，就会从源系统读取一个"新鲜"的数据。

这个过期时间可以根据你的需要进行设置。有些数据是不需要经常更新的，你可以设置
一天甚至更长的过期时间。

需要牢记的是过期时间越短，对源系统的读操作就越多，缓存的收益就越小。

###主动过期

另一种方法是主动过期，如果你的源系统更新了，你可以发消息到拥有缓存的计算机上，
使它将已经更新的数据过期掉。

主动过期的好处就是只要源系统的数据一有更新，缓存也能很快的得到更新。而且相对于
基于时间的过期，也不需要过期那些没有变化的数据。

坏处就是主动过期需要能检测到源系统的变化，如果你的源系统是个关系型数据库，而且
这个数据库被多种机制所更新，每一种机制就必须报告它更新过的数据，否则就无法发送过期消息
给拥有缓存的计算机。

##管理缓存大小

管理缓存大小也是缓存的一个重要方面。很多系统有太多重要数据要缓存，所以就需要一个管理缓存
数据的机制，管理缓存大小主要是通过驱逐(eviction)缓存中的数据来完成的。有几种驱逐的方式：

* 基于时间的驱逐
* 先进先出(FIFO)
* 先进后出(FILO)
* 最小访问频次
* 最小访问间隔

基于时间的驱逐和之前提到的基于时间的过期差不多，数据在缓存中存在一定时间后就被驱逐出去了，
这样就得有一个独立的线程去监控缓存，或者是在读写缓存的时候进行清理工作。

FIFO意思是当要插入一个新的数据到缓存里的时候，移除最早进缓存的数据。当然在缓存空间超过限制之前
不必这么做。

FILO与FIFO正好相反，这个方式相对更有用些，因为最早存储在缓存中的数据一般都是最常被访问的。

最小访问频次意思是缓存里被访问次数最少的数据最先被移除缓存。这个方法的目的是避免重复读取要经常读的
数据。要使这种方法能工作，缓存必须记录每个数据被访问的次数。需要注意的是，老的数据即便以后不再会被访问，
它们一般也会有更高的被访问次数。可能有一条数据在这之前被高频率访问过，而现在不怎么被访问了，那它依然会
因为有较高的被访问次数而不被驱逐。为了避免这种情况，可以只统计最后的N个小时。

最小访问间隔考虑的是一条数据被访问的间隔，每当一条数据被访问的时候，缓存就会记录下时间，并计算与上次
被访问的间隔，由此计算出平均访问间隔，对于上面说到的一条数据在一段时间内被高频次访问而大部分时间没怎么被
访问的情况，其平均访问间隔就会逐渐减少，最后被驱逐出缓存。

最小访问间隔的一种变体是只统计最后N次访问的间隔时间，N可以是100,1000或者对应用有意义的数字。每当访问次数
达到N的时候，访问次数重置为0，记录访问时间，这种方法可以更快的驱逐上面说到的"伪高频"数据。

最小访问间隔的另一种变体是每隔一段时间重置访问次数，然后用最小访问频次驱逐数据。比如一条数据被存入缓存的时候，
用另一个变量来统计它被访问的次数，而这个访问次数在下一个小时重置为0。这个方法与上面提到的变体有同样的效果。

最后说的两种变体区别是每次访问缓存的时候，一个检查的是访问次数有没有到N，另一个检查的是时间间隔是否超过Y。因为检查
整形integer的速度一般都要比读系统时间要快，我更倾向于第一种变体，它每隔N次访问才会读一次系统时间，而第二种每次访问
都要去读系统时间。

注意，当在进行缓存大小官吏的时候，依然需要驱逐、读取、存储数据以使数据能够和源系统同步。即使缓存数据被访问很多次而很值得
留在缓存，有些时候它还是需要做一下同步的。

##集群中的缓存

只有一台服务器的系统，其缓存还是很简单的，你可以确保所有写只存在于同一台服务器，这样你就可以使用直写缓存了。当你的应用部署
在一个拥有很多服务器的集群中时，情况就变得复杂多了。

![pic](/images/caching-3.png)

一个简单的直写缓存只能更新写数据的服务器，而其他服务器的缓存并不知道这个写操作。
在集群中你可以使用基于时间的过期或者主动过期以使所有缓存保持同步。

##缓存系统

实现你自己的缓存并不难，但是目前也存在很多现成的缓存系统。比如

* [Memcached](http://memcached.org/)
* [Ehcahe](http://ehcache.org)

以上这两个系统目前被广泛地使用。









##基础

* 学习最基本的`Bash`,读完整个man page其实花不了太长的时间,bash非常强大而且总是可用
* 学习使用`vim`,在Linux下编辑基本没有其他选择(即使你大部分时间用Emacs和Eclipse)
* 了解`ssh`,以及一些无口令认证的基本知识,如`ssh-agent`,`ssh-add`等
* 熟悉bash的作业管理:`&`,`Ctrl-Z`,`Ctrl-C`,`jobs`,`fg`,`bg`,`kill`等等
* 基本的文件管理:`ls`和`ls -l`(`ls -l`结果的每一列代表什么?), `less`, `head`, `tail` 和 `tail -f`, `ln`和`ln -s`(硬链接和软链接的区别?), `chown`, `chmod`, `du`(快速查询硬盘占用空间:`du -sk *`), `df`, `mount`
* 基本的网络管理:`ip`或者`ifconfig`, `dig`
* 了解正则表达式以及`grep/egrep`的参数
* 学习使用`apt-get`或者`yum`来寻找和安装软件包.

##日常使用

* 在bash中, 可以使用`Ctrl-R`来搜索执行过的命令
* 在bash中, 可以使用`Ctrl-W`来删除最后一个单词, 使用`Ctrl-U`来删除一行. 运行`man readline` 查看readline手册, 里面有很多默认的快捷键.
* 回到上次所在目录: `cd -`
* 使用强大的`xargs`(或者`parallel`).它允许你对输出执行其他某些命令, 你可以控制具体执行输出的哪一行(`-L`), 同样`-l{}`也是很方便的, 例子：

	find . -name \*.py | xargs grep some_function
	cat hosts | xargs -I{} ssh root@{} hostname

* `pstree -p`是个很有用的命令, 用来查看进程树
* 使用`pgrep`和`pkill`来通过名称查找或者发信号给进程(`-f`比较有用)
* 了解你能发送给进程的信号. 例如, 要暂停一个进程, 使用`kill -STOP [pid]`. 所有的信号可以通过`man 7 signal`查到
* 使用`nohup` 或者 `disdown` 以使一个后台进程永远保持运行
* 通过`netstat -lntp`来检查哪些进程正在监听,也看一下`lsof`
* 在bash脚本中, 使用`set -x`来调试输出, 使用`set -e`可以在遇到错误的时候中止.还可以试试`trap`
* 在bash脚本中,shell子进程(用括号括起来)可以很方便的组合命令. 下面是一个暂时切换到其他工作目录的例子:


	\# do something in current dir
	(cd /some/other/dir; other-command)
	\# continue in original dir


* 在bash中，有很多种变量扩展.检查一个变量是否存在: `${name:?error message}`.例如, 如果bash脚本需要有一个参数, 就可以写成`input_file=${1:?usage: $0 input_file}`. 算术扩展: `i=$(( (i+1) % 5 ))`. 序列:`{1..10}`. 修剪字符串: `${var%后缀}` 和 `${var#前缀}`.例子: 如果var=foo.pdf, 那么`echo ${var%.pdf}.txt`的结果是"foo.txt".
* 通过`<(命令)`, 一个命令的输出可以被当成一个文件. 例如, 比较本地和远程的/etc/hosts: `diff /etc/hosts <(ssh somehost cat /ect/hosts)`
* 了解bash中的here documents", 特别是`cat<<EOF`的用法
* 在bash中，将标准输出和错误同时重定向: `some-command >logfile 2>&1`. 对于输入来说, '</dev/null'是个不错的选择
* 通过`man ascii`可以查看ASCII码的表格
* 在远程ssh会话中，使用`screen`或者`dtach`来管理你的会话'
* 对于web调试, `curl`和`curl -I`很方便, 还有`wget`
* 将HTML转化成文本文件: `lynx -dump -stdin`
* 如果你必须处理xml, xmlstarlet是不错的选择
* 对ssh配置进行一些优化将非常有用;例如

##数据处理

* 了解`sort`和`uniq`(包括`uniq`的-u和-d参数)
* 使用`cut`, `paste`, `join`来处理文本文件
* 通过`sort`和`uniq`可以取文本文件的交集, 并集和不同.


	cat a b | sort | uniq > c   # c是并集
	cat a b | sort | uniq -d > c   # c 是交集
	cat a b b | sort | uniq -u > c   # c 是 a-b


* 语言环境影响很多命令行工具，包括排序的顺序和性能.大部分Linux会将LANG和其他语言环境变量设置成US_EN或者ZH_CN这样的本地化值.这样会导致`sort`和其他命令运行很慢, 如果想使用传统的字节排序, 使用`export LC_ALL=C`(可以考虑将这条命令放入.bashrc中)
* 使用`awk`和`sed`对数据进行分割.例如,将一个文件中第三列的所有数字相加: `awk '{ x += $3 } END { print x }'`.这可能比用python要快三倍
* 使用`shuf`来打乱一个文件的所有行
* 了解`sort`的参数. 了解`-t`和`-k`是怎么工作的. 注意如果想按照第一个域进行排序用的是`-k1,1`; `-k1`意思是按照整行排序
* 稳定排序(`sort -s`)也很有用. 例如, 先按照第2个域排序,再按照第1个域排序: `sort -k1,1 | sort -s -k2,2`
* 如果你需要在命令行中输入tab，使用`Ctrl-V <tab>`或者`$'\t'`(后者更好因为可以复制粘贴)
* 转换编码可以使用`iconv`, 或者更高级的`uconv`;
* `split`可以将大文件分割成小文件

##系统调试

* 如果想要知道磁盘/cpu/网络的状态, 使用`iostat`, `netstat`, `top`, `dstat`.
* 如果想要知道内存的状态, 使用`free`和`vmstat`.
* 对于java系统调试,你可以运行`kill -s <pid>`, 堆栈信息(包括垃圾回收信息)会被dump到标准错误或者logs中
* 使用`mtr`取代`traceroute`来查看网络状态
* 使用`iftop`或者`nethogs`查看哪些socket或者进程在使用带宽
* `ab`工具(来自Apache)用于查看网络服务器性能.对于更复杂的负载测试, 用`siege`
* 如果要更详细地调试网络, 使用`wireshark`或者`tshark`
* 了解`strace`和`ltrace`. 当程序失败,挂起或者崩溃的时候,用这两个命令来找原因，也可以了解到程序的性能. 注意参数`-c`和`-p`
* 使用`ldd`检查共享库
* 知道怎么用`gdb`连接到运行中的进程并获取到它的堆栈信息
* 使用/proc文件夹.例如:/proc/cpuinfo, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps
* 对于更深层次的系统分析, 看一下`stap`(systemtap)和`perf`
* 使用`dmesg`查看内核侦测信息(主要是硬件和驱动)






























