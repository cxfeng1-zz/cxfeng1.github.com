---
layout: post
title: "缓存技术"
description: ""
category: Programming
tags: [Caching]
---
{% include JB/setup %}

缓存是一项加速数据读取的技术。有了缓存之后，你就不用再直接回源去取数据了，这个“源”可能是数据库，也可能是其他的远程系统。
基本的缓存原则如下图：

![pic](/images/caching-1.png)

所谓缓存，其实就是比“源”更“近”的一个存储区域，从缓存中读取数据一般比从源数据读取要更快。
缓存一般存储中内存或者磁盘中。内存比磁盘更快，但是内存中的缓存会在系统重启后消失。

典型的软件系统中，数据缓存会发生在很多不同的层级。目前的web应用一般会在三个层级上使用缓存：

![pic](/images/caching-2.png)

大多数web应用会使用数据库。数据库可以把数据缓存在内存中这样就不用每次从磁盘中读取了。同样的，
web服务器可以缓存一些如图片、CSS文件，JS文件之类的静态数据在内存中，也可以缓存从数据库中读取的数据，这样
它就不用每次都去数据库读数据了。最后浏览器也可以缓存静态的文件和数据，HTML5浏览器有
[local storage](http://tutorials.jenkov.com/html5/local-storage.html),[Appcache](http://www.html5rocks.com/en/tutorials/appcache/beginner/)
以及[web SQL 数据库](http://html5doctor.com/introducing-web-sql-databases/)

在实现一个缓存系统的时候，你需要考虑三件事情：

* 怎么填充缓存
* 怎么保持缓存和源数据的同步
* 怎么管理缓存的大小

##填充缓存

第一个挑战便是怎么用源数据来填充缓存。一般有两种方式:

* 预填充
* 懒填充

预填充意思就是在拥有缓存的系统启动的时候就把需要的值存储到缓存中去。
这个方式需要你能够预先知道该缓存哪些内容。

懒填充意思是当你需要某些数据的时候，首先去检查缓存中有没有，没有就从源系统中获取
并填充到缓存中。

预填充和懒填充的好处和坏处可以用下表概括：

<table>
<tr>
<td></td>
<td>好处</td>
<td>坏处</td>
</tr>
<tr>
<td>预填充</td>
<td>预填充没有第一次读取数据的延时</td>
<td>初始化缓存花费时间长，同时可能会缓存永远都用不到的数据</td>
</tr>
<tr>
<td>懒填充</td>
<td>懒填充只缓存真正需要的数据，也没有初始构建时的延时</td>
<td>在第一次读取数据时还是要从源服务器读，前后用户体验会不一致
</tr>
</table>


当然，可以将预填充和懒填充结合起来，预先将经常被读取的数据放入缓存，
然后其余的数据通过懒填充放入缓存。

##保持缓存和源数据同步

这同样是一个很大的挑战，基于系统结构的不同，同步的方法也有很多。

###直写缓存

直写缓存是一种既允许读又允许写的缓存，如果有数据写入缓存，那这些数据
同样会写到源系统中，所以称它为"直写"。

直写缓存主要应用于源系统只能被缓存所更新的情况。如果所有数据写入都是
拥有缓存的计算机造成的，那通过写入源系统来保持同步就比较简单了。

###基于时间过期

如果源系统的数据更新跟拥有缓存的计算机无关，那就不适合用直写了。

有一种同步方法是让数据在缓存中存在一定的时间，过期了数据就会从缓存中删除。
当又需要这个数据的时候，就会从源系统读取一个"新鲜"的数据。

这个过期时间可以根据你的需要进行设置。有些数据是不需要经常更新的，你可以设置
一天甚至更长的过期时间。

需要牢记的是过期时间越短，对源系统的读操作就越多，缓存的收益就越小。

###主动过期

另一种方法是主动过期，如果你的源系统更新了，你可以发消息到拥有缓存的计算机上，
使它将已经更新的数据过期掉。

主动过期的好处就是只要源系统的数据一有更新，缓存也能很快的得到更新。而且相对于
基于时间的过期，也不需要过期那些没有变化的数据。

坏处就是主动过期需要能检测到源系统的变化，如果你的源系统是个关系型数据库，而且
这个数据库被多种机制所更新，每一种机制就必须报告它更新过的数据，否则就无法发送过期消息
给拥有缓存的计算机。

##管理缓存大小

管理缓存大小也是缓存的一个重要方面。很多系统有太多重要数据要缓存，所以就需要一个管理缓存
数据的机制，管理缓存大小主要是通过驱逐(eviction)缓存中的数据来完成的。有几种驱逐的方式：

* 基于时间的驱逐
* 先进先出(FIFO)
* 先进后出(FILO)
* 最小访问频次
* 最小访问间隔

基于时间的驱逐和之前提到的基于时间的过期差不多，数据在缓存中存在一定时间后就被驱逐出去了，
这样就得有一个独立的线程去监控缓存，或者是在读写缓存的时候进行清理工作。

FIFO意思是当要插入一个新的数据到缓存里的时候，移除最早进缓存的数据。当然在缓存空间超过限制之前
不必这么做。

FILO与FIFO正好相反，这个方式相对更有用些，因为最早存储在缓存中的数据一般都是最常被访问的。

最小访问频次意思是缓存里被访问次数最少的数据最先被移除缓存。这个方法的目的是避免重复读取要经常读的
数据。要使这种方法能工作，缓存必须记录每个数据被访问的次数。需要注意的是，老的数据即便以后不再会被访问，
它们一般也会有更高的被访问次数。可能有一条数据在这之前被高频率访问过，而现在不怎么被访问了，那它依然会
因为有较高的被访问次数而不被驱逐。为了避免这种情况，可以只统计最后的N个小时。

最小访问间隔考虑的是一条数据被访问的间隔，每当一条数据被访问的时候，缓存就会记录下时间，并计算与上次
被访问的间隔，由此计算出平均访问间隔，对于上面说到的一条数据在一段时间内被高频次访问而大部分时间没怎么被
访问的情况，其平均访问间隔就会逐渐减少，最后被驱逐出缓存。

最小访问间隔的一种变体是只统计最后N次访问的间隔时间，N可以是100,1000或者对应用有意义的数字。每当访问次数
达到N的时候，访问次数重置为0，记录访问时间，这种方法可以更快的驱逐上面说到的"伪高频"数据。

最小访问间隔的另一种变体是每隔一段时间重置访问次数，然后用最小访问频次驱逐数据。比如一条数据被存入缓存的时候，
用另一个变量来统计它被访问的次数，而这个访问次数在下一个小时重置为0。这个方法与上面提到的变体有同样的效果。

最后说的两种变体区别是每次访问缓存的时候，一个检查的是访问次数有没有到N，另一个检查的是时间间隔是否超过Y。因为检查
整形integer的速度一般都要比读系统时间要快，我更倾向于第一种变体，它每隔N次访问才会读一次系统时间，而第二种每次访问
都要去读系统时间。

注意，当在进行缓存大小官吏的时候，依然需要驱逐、读取、存储数据以使数据能够和源系统同步。即使缓存数据被访问很多次而很值得
留在缓存，有些时候它还是需要做一下同步的。

##集群中的缓存

只有一台服务器的系统，其缓存还是很简单的，你可以确保所有写只存在于同一台服务器，这样你就可以使用直写缓存了。当你的应用部署
在一个拥有很多服务器的集群中时，情况就变得复杂多了。

![pic](/images/caching-3.png)

一个简单的直写缓存只能更新写数据的服务器，而其他服务器的缓存并不知道这个写操作。
在集群中你可以使用基于时间的过期或者主动过期以使所有缓存保持同步。

##缓存系统

实现你自己的缓存并不难，但是目前也存在很多现成的缓存系统。比如

* [Memcached](http://memcached.org/)
* [Ehcahe](http://ehcache.org)

以上这两个系统目前被广泛地使用。

